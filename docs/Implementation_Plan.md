## Implementation Plan — Итоговая лабораторная работа (Частотный анализ текста)

1. **Краткое описание задачи**  
   Реализовать консольное C++‑приложение, которое загружает текст и список стоп‑слов из пользовательского JSON, выполняет частотный анализ (по словам, предложениям, длинам слов) и формирует человекочитаемый отчёт, а также позволяет измерять время работы ключевых операций.

2. **Цель и ожидаемый результат**  
   На выходе ожидается:  
   - исполняемый CLI‑инструмент `textfreq_cli` с флагами `--help`, `--input`, `--stops`, `--report freq`, `--top`, `--output`;  
   - набор примерных входных JSON‑файлов (`data/`), включая крупный для бенчмарков и файлы с ошибками;  
   - форматированный текстовый отчёт о частотах и распределении по длине;  
   - отчёт по бенчмаркам (`docs/bench.md`) и общий отчёт по работе (`docs/report.md`).

3. **Этапы и задачи реализации**

   1. **Анализ формата JSON и требований**  
      - Определить допустимые структуры входных данных: `{ "text": "..." }` и массив параграфов `[{ "paragraph": "..." }, ...]`.  
      - Определить формат списка стоп‑слов: массив строк или объектов `{ "stop": "..." }`.  
      - Уточнить ограничения минимального подмножества JSON (объекты, массивы, строки, числа, `true/false/null`, базовые экранирования).

   2. **Проектирование структур данных и API**  
      - Спроектировать минимальный DOM‑подобный тип `json::Value` (variant: null, bool, number, string, array, object).  
      - Описать интерфейсы: `json::Parser`, `extract_text_blocks`, `extract_stopwords`, `analyze_text`, `format_report`, `parse_arguments`.  
      - Спроектировать структуру `TextStats` с полями для всех требуемых метрик.

   3. **Реализация ввода и валидации JSON**  
      - Написать ручной парсер JSON в `src/json_parser.cpp` с проверкой на ошибки и позицию.  
      - Реализовать функции извлечения текстовых блоков и стоп‑слов из разобранного дерева с нормализацией регистра.  
      - Обработать граничные случаи: пустой массив, отсутствие ключей, пустые строки.

   4. **Реализация алгоритмов частотного анализа**  
      - Написать разбор текста на слова и предложения с учётом пунктуации и нормализации регистра.  
      - Подсчитать общее количество слов, предложений, уникальных слов.  
      - Реализовать подсчёт частот (с учётом и без стоп‑слов) и распределение по длине слов.  
      - Сформировать функции форматирования отчёта в виде компактных таблиц и сводки.

   5. **CLI и UX консоли**  
      - Реализовать разбор аргументов командной строки (`--help`, `--input`, `--stops`, `--report`, `--top`, `--output`).  
      - Добавить человеко‑дружественные сообщения об ошибках (что произошло, что делать пользователю).  
      - Обеспечить выравнивание колонок в отчёте, примеры использования в `--help`.

   6. **Тестирование и обработка ошибок**  
      - Добавить самотесты в `tests/` для парсера JSON, извлечения данных и анализа текста.  
      - Подготовить позитивные и негативные JSON‑примеры (ошибочный формат, пустые блоки).  
      - Проверить граничные случаи (пустой текст, только пунктуация, только стоп‑слова).

   7. **Бенчмаркинг и анализ производительности**  
      - Реализовать бенч‑сценарии в `tests/` с использованием `std::chrono` для больших текстов.  
      - Считать время парсинга JSON и анализа текста (горячее место — разбор большого текста и подсчёт частот).  
      - Зафиксировать результаты в `docs/bench.md`, провести анализ и предложить оптимизации (например, уменьшение временных аллокаций, более эффективные структуры данных).

   8. **Оформление и документация**  
      - Дописать `README.md` с инструкциями по сборке, запуску и демонстрационным сценарием.  
      - Подготовить основной отчёт (`docs/report.md`) с описанием архитектуры, формата JSON, UX, тестов и бенчмарков.  
      - Добавить в `docs/` логи запуска тестов и пример форматированного вывода.

4. **План‑график (условный)**  
   - Неделя 1: анализ задания, проектирование структур данных и интерфейсов, черновик Implementation Plan.  
   - Неделя 2: реализация парсера JSON и базового CLI, простые тесты.  
   - Неделя 3: реализация алгоритмов анализа и форматирования отчёта, обработка ошибок и UX.  
   - Неделя 4: добавление бенчмарков, генерация данных, написание отчёта и финальная полировка.

5. **Ресурсы**  
   - Язык: C++17.  
   - Инструменты: CMake, компилятор (g++, clang++ или MSVC), консоль Windows.  
   - Материалы: текст задания (PDF/DOCX), примеры JSON из варианта, документация по std::chrono, стандартной библиотеке C++.  
   - Дополнительно: GitHub‑репозиторий для хранения кода, истории коммитов и документации.


